
\chapter{Linguagens Livres do Contexto}\label{cap:LinguagemLLC}

\begin{introduction}[Tópicos]
	\item Gramática Livres do Contexto
	\item Simplificação e Formas Normais de GLC
	\item Sobre Algoritmos de Pertinência em GLC
	\item GLC e Linguagens de Programação
	\item Autômato de Pilha
	\item Álgebras das LLC
	\item Problemas de Decisão das LLC
	\item Questionário
\end{introduction}

No capítulo passado foram apresentadas três diferentes formalismos para a classe das linguagens regulares, a saber, o formalismo operacional (os autômatos), o formalismo denotacional (as expressões regulares) e por fim o formalismo gerador ou axiomático (as gramáticas regulares). Agora este manuscrito irá continuar o estudo das linguagens formais apresentando a classe das linguagens livres do contexto, como antes serão apresentados diferentes formalismo para tal classe de linguagens.

\section{Gramática Livres do Contexto}\label{sec:GLC}

O estudo das Linguagens Livres do Contexto será iniciado aqui pela apresentação de seu formalismo gerador, ou seja, será primeiro apresentado a noção de Gramática Livre do Contexto.

\begin{definition}[Gramática Livre do Contexto]\label{def:GLC}
	\cite{benjaLivro2010} Uma Gramática Livre do Contexto, ou simplesmente GLC, é uma gramática formal $G = \langle V, \Sigma, S, P\rangle$ onde todo $\alpha \rhd \beta \in P$ é tal que $\alpha \in V$ e $\beta \in (V \cup \Sigma)^*$.
\end{definition}

\begin{example}\label{exe:GLC-1}
	A estrutura $G = \langle \{A, B, C\}, \{0,1\}, A, P\rangle$ onde $P$ é definido pela regras:
	\begin{eqnarray*}
		A & \rhd & A0110BC \mid 0110C \mid AAB0110CC \mid \lambda\\
		B & \rhd & 01B10 \mid 0110\\
		C & \rhd & 01C \mid \lambda
	\end{eqnarray*}
	é uma GLC.
\end{example}

Obviamente o leitor atento pode notar que a Definição \ref{def:GLC} garante que toda Gramática Regular é um caso particular de GLC, porém o inverso não é verdadeiro, basta notar que a gramática apresentada no Exemplo \ref{exe:GLC-1}, fere a definição de gramática regular apresentada na Seção \ref{sec:GramaticaRegular} do capítulo passado. Agora utilizando a Definição \ref{def:LinaugemGramatica} pode-se formalizar o conceito de Linguagem Livre do Contexto.

\begin{definition}[Linguagem Livre do Contexto]\label{def:LLC}
	A linguagem $L$ gerada por uma GLC $G$, ou seja, $L = \mathcal{L}(G)$, será chamada de Linguagem Livre do Contexto, ou simplesmente LLC.
\end{definition}

Como para os casos das linguagens reconhecidas por AFD, para provar que uma determinada GLC $G$ gera uma linguagem $L$ é necessário demonstrar o seguinte resultado $w \in L \Longleftrightarrow w \in \mathcal{L}(G)$.

\begin{example}\label{exe:LinguagemGLC}
	A linguagem $L = \{a^ib^i \mid i  > 0\}$ é gerado pela GLC $G = \langle \{S\}, \{a,b,c\}, S, P\rangle$ onde $P$ é formado pelas regras,
	\begin{eqnarray*}
		S & \rhd & aSb \mid ab
	\end{eqnarray*}
	\begin{proof}
		$(\Rightarrow)$ Suponha que $w \in L$ assim $w = a^ib^i$ para $i  > 0$, agora por indução sobre a quantidade $n$ de derivações em $G$ será mostrado que toda forma sentencial gerada por $G$ é da forma $a^nS^jb^n$ com $j \in \{0, 1\}$. 
		\begin{itemize}
			\item[ ] \textbf{Base da indução}: Com $n = 1$, é trivial pelas regras em $P$. 
			\item[ ] \textbf{Hipótese indutiva (HI)}: Assuma que com $n$ derivações tal que $n \geq 0$ a forma sentencial $a^nS^jb^n$ é gerada pela GLC $G$, ou seja, $S \gg^n a^nS^jb^n$ com $j \in \{0, 1\}$. 
			\item[ ] \textbf{Passo indutivo}: Agora dado $S \gg^{n+1} w'$, ou seja, $w'$ é derivada de $S$ com $n+1$ derivações, assim por definição tem-se que existe $w''$ tal que $S \gg^n w'' \gg w'$, mas por \textbf{(HI)} tem-se que $w'' =  a^nS^jb^n$ com $n \geq 0$ e $j \in \{0, 1\}$,  desde que, $w'$ é gerada de $w''$ é claro que $j = 1$, ou seja, $w'' = a^nSb^n$, consequentemente, $w' = a^{n+1}Sb^{n+1}$ ou $w' = a^{n+1}b^{n+1}$ e, portanto, $w'$ é da forma $a^{n+1}S^jb^{n+1}$ com $j \in \{0, 1\}$. 
		\end{itemize}
		Agora por hipótese tinha-se que $w = a^ib^i$ para $i  > 0$, ou seja, $w = a^iS^0b^i$, dessa forma pela indução acima $w$ é uma forma sentencial gerada por $G$, e como $w \in \Sigma^*$ tem-se por definição que $w \in \mathcal{L}(G)$. $(\Rightarrow)$ Suponha que $w \in \mathcal{L}(G)$, agora será mostrado por indução sobre a quantidade $n$ de derivações que todo $w$ gerado por $G$ estará em $L$.
		\begin{itemize}
			\item[ ] \textbf{Base da indução:} Com $n=1$, ou seja, como uma única derivação, pelo fato de que $w \in \Sigma^*$ e pelas regras em $P$ tem-se obrigatoriamente que $w = ab$ e, portanto, $w = a^1b^1$ , consequentemente, $w \in L$.
			\item[ ] \textbf{Hipótese indutiva (HI)}: Assuma que para todo $S \gg^n w$ tal que $n \geq 1$, tem-se que $w \in L$.
			\item[ ] \textbf{Passo indutivo}: Agora dado $S \gg^{n+1} w$, ou seja, $w$ é derivado em $G$ com $n + 1$ derivações de forma que $n \geq 1$. Desde que $n  \geq 1$ tem-se que $n + 1  > 1$, assim a palavra $ab$ não pode ser $w$ uma vez que são usadas pelo menos duas derivações para gerar $w$. Assim a derivação de $w$ deverá ter sido iniciado usando a regra $S \rhd aSb$ e, portanto, $w = aw'b$ em que $S \gg^n w'$, mas pela hipótese indutiva $w' \in L$, logo $w' = a^ib^i$ com $i > 0$, consequentemente $w = aa^ib^ib = a^{i+1}b^{i+1}$, logo $w \in L$.
		\end{itemize}
	\end{proof}
\end{example}

Note que para a prova mostrada no Exemplo \ref{exe:LinguagemGLC} foi-se usada indução sobre o tamanho das derivações, isto não é a única forma de se proceder para provar que uma gramática gera uma determinada linguagem, de  fato como apresentado em \cite{hopcroft2008} pode-se usar a ideia de indução sobre as árvores de derivações (apresentadas mais a frente), neste manuscrito não será apresentado tal estratégia, porém fica a referência para interessados no tema. 

Nas GLC que não são lineares, ou seja, as gramática em que as regras em $P$ podem conter duas ou mais variáveis do lado direto do símbolo $\rhd$, é permitido a escolha sobre qual variável ser derivada primeiramente, para ilustrar isso considere uma forma sentencial $0A10BC$ e as regras $A \rhd 00, B \rhd \lambda$ e $C \rhd 1$, note que dependendo de qual variável é escolhida para ser reescrita a próxima forma sentencial pode assumir três formas diferentes. Apresentado esta ideia pode-se agora formalizar o conceito de reescrita \textbf{mais à esquerda} e \textbf{mais à direita}.

\begin{definition}[Tipos de Derivação]\label{def:TiposLateraisReescrita}
	Dado uma GLC $G = \langle V, \Sigma, S, P\rangle$ e seja $w_1A_1w_2\cdots w_nA_nw_{n+1}$ uma forma sentencial derivável em $G$ tal que $w_i \in \Sigma^*$ e $A_j \in V$ para todo $1 \leq i \leq n+1$ e $1 \leq j \leq n$. Uma derivação é dita mais à esquerda (à direita) se ela é da forma $w_1A_1w_2\cdots w_nA_nw_{n+1} \gg w_1w'w_2\cdots w_nA_nw_{n+1}$ ($w_1A_1w_2\cdots w_nA_nw_{n+1} \gg w_1A_1w_2\cdots w_nw'w_{n+1}$)  com  $w' \in (V \cup \Sigma)^*$.
\end{definition}

\begin{example}\label{exe:ReescritasLaterais}
	Considere a GLC $G = \langle \{S, A, B\}, \{0, 1\}, S, P\rangle$ em que $P$ é formado pelas regras,
	\begin{eqnarray*}
		S & \rhd & 0AB\\
		A & \rhd & 11B1 \\
		B & \rhd & A \mid \lambda 
	\end{eqnarray*}
	claramente a palavra $011B1A$ é um forma sentencial derivável em $G$, agora note que:
	\begin{eqnarray*}
		011B1A & \gg & 011A1A\\
		011B1A & \gg & 0111A
	\end{eqnarray*}
	são ambas derivações mais à esquerda, e 
	\begin{eqnarray*}
		011B1A & \gg & 011B111B1
	\end{eqnarray*}
	é uma derivação mais à direita.
\end{example}

\begin{definition}[Tipo de Geração]\label{def:TipoGeracao}
	Dado uma GLC $G = \langle V, \Sigma, S, P\rangle$,  uma derivação $S \gg^* w$ é dita ser uma geração mais à esquerda (à direita) sempre que $w \in \Sigma^*$ e toda derivação realizada for mais à esquerda (à direita).
\end{definition}

\begin{example}\label{exe:TipoGeracao}
	Considere a gramática do Exemplo \ref{exe:ReescritasLaterais} a derivação, 
	$$S \gg 0AB \gg 011B1B \gg 0111B \gg 0111$$
	é claramente uma geração mais à esquerda, já a derivação
	$$S \gg 0AB \gg 0A \gg 011B1 \gg 0111$$
	é notavelmente uma geração mais à direita.
\end{example}

\begin{remark}
  Resumindo dado uma GLC $G = \langle V, \Sigma, S, P\rangle$ uma geração é obrigatoriamente uma derivação $S \gg w$ em que $w \in \Sigma^*$, ou seja, uma derivação que gera (ou produz) uma palavra sobre o alfabeto $\Sigma$.
\end{remark}

Além da noção de geração, para visualizar o passo a passo da ``construção'' de uma palavra $w \in \Sigma^*$ em uma GLC $G$ é comum usar a ideia de árvore de derivação\footnote{Na literatura como no livro \cite{benjaLivro2010} também é comum encontrar a nomenclatura árvore ordenada.}. 

Uma árvore de derivação nada mais é do que uma forma visual estruturada em uma árvore\footnote{As árvores de derivação são representações cuja a forma similar a construção das árvores $n$-árias da área de estrutura de dados \cite{jaime1994}.} que representar a construção de uma palavra, em que cada nível da árvore representa é gerada pela aplicação de uma ou mais regras de reescrita, neste sentido as folhos da árvore contém os símbolos da palavra $w$.

\begin{definition}[Árvore de Derivação]\label{def:ArvoreGLC}
	Seja $G = \langle V, \Sigma, S, P\rangle$ uma GLC e dado $w \in \mathcal{L}(G)$, uma árvore de derivação para $w$ é construída seguindo as seguintes regras:
	\begin{enumerate}
		\item O símbolo $S$ é a raiz da árvore.
		\item Todo símbolo $a \in \Sigma \cup \{\lambda\}$ é o rótulo de uma folha.
		\item Todo símbolo $A \in V$ é o rótulo de uma raiz de uma sub-árvore\footnote{Aqui sub-árvore e no mesmo sentido que o leitor já deve ter visto em estrutura de dados.}.
		\item Se $A$ é uma raiz e seus ``filhos'' são  $x_1, \cdots, x_n$ com $x_i \in V \cup \Sigma \cup \{\lambda\}$ para $1 \leq i \leq n$, então existe em $P$ uma regra da forma $A \rhd x_1\cdots x_n$.
		\item Todo folha rotulada por $\lambda$ de uma raiz $A$ será filho único, ou seja, em $P$ existe uma regra da forma $A \rhd \lambda$.
	\end{enumerate}
\end{definition}

\newpage
\begin{example}\label{exe:ArvoreGLC1}
	Tem-se que a derivação $S \gg 0AB \gg 011B1B \gg 0111B \gg 0111$ apresentada no Exemplo \ref{exe:TipoGeracao} é representada pela árvore esboçada na Figura \ref{fig:ArvoreGLC1} a seguir.
	
	\begin{figure}[h]
		\centering
		\begin{tikzpicture}[sibling distance=.6cm, empty/.style={draw=none}, tlabel/.style={font=\footnotesize\color{red!70!black}}]
			\Tree   [.$S$  
					[.$0$ ]
						%\edge node[tlabel,auto=left] {1}; 
					[.$A$  
							[.$1$ ]
							[.$1$ ]
							[.$B$ 
								{$\lambda$}
							] 
							[.$1$ ]
					] 
					[.B   
						%\edge[empty]; {} \edge node[tlabel,auto=left] {5}; {b}   
						{$\lambda$}
					]
			]
		\end{tikzpicture}
		\caption{Árvore para a derivação $S \gg 0AB \gg 011B1B \gg 0111B \gg 0111$.}
		\label{fig:ArvoreGLC1}
	\end{figure}
\end{example}

\begin{example}\label{exe:ArvoreGLC2}
	Tem-se que a derivação $S \gg 0AB \gg 0A \gg 011B1 \gg 0111$ apresentada no Exemplo \ref{exe:TipoGeracao} é representada pela árvore esboçada na Figura \ref{fig:ArvoreGLC2} a seguir.
	
	\begin{figure}[h]
		\centering
		\begin{tikzpicture}[sibling distance=.6cm, empty/.style={draw=none}, tlabel/.style={font=\footnotesize\color{red!70!black}}]
			\Tree [.$S$  
					[.$0$ ]
					[.$A$
						[.$1$ ] 
						[.$1$ ] 
						[.$B$ 
							{$\lambda$}
						] 
						[.$1$ ] 
					]
					[.$B$
						{$\lambda$} 
					]
			]
		\end{tikzpicture}
		\caption{Árvore para a derivação $S \gg 0AB \gg 0A \gg 011B1 \gg 0111$.}
		\label{fig:ArvoreGLC2}
	\end{figure}
\end{example}

\begin{remark}
	Os Exemplos \ref{exe:ArvoreGLC1} e \ref{exe:ArvoreGLC2} mostram que que diferentes derivações podem ser representadas pela mesma árvore, isso acontece devido ao fato de que a árvore de derivação apenas esboça o processo de formação total (ou final), e não o comportamento (ou momento) parcial das derivação.
\end{remark}

\begin{note}
	Em algumas obras tais como \cite{benjaLivro2010} as folhas e raízes nas árvores de derivação são gravados com círculos, neste manuscrito isso não será feito para não confundir o leitor iniciante com a representação visual dos autômatos finitos.
\end{note}

\begin{definition}[Ambiguidade]\label{def:AmbiguidadePalavra}
	Dado uma GLC $G = \langle V, \Sigma, S, P\rangle$ uma palavra $w \in \mathcal{L}(G)$ é dita ser ambígua sempre que existe duas gerações diferentes para $w$.
\end{definition}

A Definição \ref{def:AmbiguidadePalavra} pode ser reinterpretada da seguinte forma: uma palavra $w$ é ambígua com relação a uma GLC $G$ se existem duas gerações mais à esquerda (à direta) para tal palavra.

\begin{definition}[Linguagem Ambígua]\label{def:LinguagemAmbiguidade}
	Uma linguagem $L$ é dita ser ambígua se existe uma GLC $G$ e uma palavra $w$ tal que $L = \mathcal{L}(G)$ e $w$ seja uma palavra ambígua em $G$. L será dita inerentemente ambígua se existe $w$ para todo GLC $G$ tal que  $w$ seja uma palavra ambígua em $G$ e $L = \mathcal{L}(G)$.
\end{definition}

\begin{example}
	Considere a GLC $G = \langle \{S\}, \{a, b\}, S, P \rangle$ onde $P$ é o formado pelas seguintes regras:
	\begin{eqnarray*}
		S & \rhd & aSb \mid SS \mid \lambda
	\end{eqnarray*}
	a palavra $aabb$ é ambígua, pois existem as duas árvores de derivação apresentadas na Figura \ref{fig:ArvoresAmbuigas}, assim tem-se que $\mathcal{L}(G)$ é uma linguagem ambígua.
	
	\begin{figure}[h]
		\centering
		\subfloat[Primeira ávore.]{
			\begin{tikzpicture}[sibling distance=.8cm, empty/.style={draw=none}, tlabel/.style={font=\footnotesize\color{red!70!black}}]
				\Tree [.$S$  
						[.$a$ ]
						[.$S$
							[.$a$ ] 
							[.$S$
								{$\lambda$} 
							] 
							[.$b$ ] 
						]
						[.$b$ ]
				]
			\end{tikzpicture}
			\label{Ima:Arvore1}
		}\hfill
		\subfloat[Segunda ávore.]{
			\begin{tikzpicture}[sibling distance=.8cm, empty/.style={draw=none}, tlabel/.style={font=\footnotesize\color{red!70!black}}]
				\Tree [.$S$  
						[.$S$
							{$\lambda$} 
						]
						[.$S$
							[.$a$ ]
							[.$S$
								[.$a$ ] 
								[.$S$
									{$\lambda$} 
								] 
								[.$b$ ] 
							]
							[.$b$ ] 
						]
				]
			\end{tikzpicture}
			\label{Ima:Arvore2}
		}%
		\caption{As árvores de derivação para a palavra $aabb$}
		\label{fig:ArvoresAmbuigas}
	\end{figure}
\end{example}

Ambiguidade é uma característica comum encontrada nas linguagem naturais \cite{benjaLivro2010} e em tais linguagens essa característica é tolerada, em contrapartida, as linguagens de programação não toleram muito bem o aspecto da ambiguidade assim em geral a mesma deve ser sempre que possível evitada ou eliminada. Uma estratégia comum para a eliminação da ambiguidade em linguagens de programação é estabelecer prioridade na geração de certos símbolos da linguagens \cite{benjaLivro2010, aho2007}. 

\section{Simplificação de Gramática Livres do Contexto}\label{sec:SimplficacaoGLC}

Antes de apresentar as regras de simplificação e alguns resultados sobre as mesmas é conveniente discutir alguns aspectos sobre as GLC. Antes de tudo lembre que na definição de GLC (Definição \ref{def:GLC}) não existe qualquer restrição para a forma das palavras encontradas à direita das regras de reescrita. Assim podem haver $n$ variáveis, recursão, geração de $\lambda$ e etc. Algumas desta, entretanto, podem ser removidas ou alteradas de forma que a gramática possa ser mais simples de ser utilizada, e será isto que será estudado nesta seção, ou seja, aqui será estudado diversas estratégias para transformar uma gramática qualquer $G$ em uma gramática $G'$ com alguns restrições, mas que preserva a linguagem gerada, isto é, $\mathcal{L}(G) = \mathcal{L}(G')$. 

\begin{remark}
    Assim como em \cite{benjaLivro2010} as gramáticas que serão consideradas nesta seção não são capazes de gerar a palavra vazia, ou seja, $S \not\gg \lambda$ ou ainda $\lambda \notin \mathcal{L}(G)$. Entretanto isso não irá diminuir em nada a força dos resultados que serão obtidos aqui.
\end{remark}

\begin{definition}[Regra da substituição]\label{def:RegraSubstituicao}
    Seja $G = \langle V, \Sigma, S, P\rangle$ uma GLC e seja $A, B \in V$ tal que $A \neq B$ de forma que em $P$ existem as produções:
    $$A \rhd x_1Bx_2$$
    e
    $$B \rhd y_1 \mid y_2 \mid \cdots \mid y_n$$
    a regra de substituição consiste em para cada a regra $A \rhd x_1A x_2$ em $P$ adicionar as regras:
    $$A \rhd x_1y_1x_2 \mid x_1y_2x_2 \mid \cdots \mid x_1y_nx_2 \mid$$.
\end{definition}

Note que a regra de substituição de fato só altera a forma do conjunto $P$ gerando um novo conjunto $P'$, e pela própria regra é fácil notar que vale a seguinte desigualdade $\# P \leq \# P'$. 

\begin{theorem}\label{teo:SuplificacaoGLC-Sub}
    Se $G = \langle V, \Sigma, S, P\rangle$ é uma GLC, então a gramática $G'$ gerada a partir da regra de substituição é tal que $\mathcal{L}(G) = \mathcal{L}(G')$.
\end{theorem}

\begin{proof}
    Suponha $G = \langle V, \Sigma, S, P\rangle$ é uma GLC, agora seja $G' = \langle V, \Sigma, S, P'\rangle$ a GLC gerada a partir da regra de substituição aplicada a $G$. Agora assuma que $w \in \mathcal{L}(G)$, ou seja, $S \gg_G^* w$, dessa forma há dois casos para serem considerados:
    \begin{itemize}
        \item[(1)] Se durante a derivação $S \gg_G^* w$ não forem usadas regras da forma $A \rhd x_1Bx_2$, então obviamente essa mesma derivação pode ser replicada em todos os seu detalhes na gramática $G'$, uma vez que, todas as regras que não são da forma $A \rhd x_1Bx_2$ estão também em $P'$, assim $S \gg_{G'}^* w$, consequentemente, $w \in \mathcal{L}(G')$.
        \item[(2)] Agora sem perda de generalidade assuma que pelo menos uma regra da forma  $A \rhd x_1Bx_2$ seguida da regra $B \rhd y_1$ aparecem na derivação $S \gg_G^* w$, portanto, tem-se que:
        $$S \gg_G^* k_1Ak_2 \gg_{G} k_1x_1Bx_2k_2 \gg_{G} k_1x_1y_1x_2k_2 \gg^*_G w $$
        com $k_1, k_2, x_1, x_2, y_1 \in (V \cup \Sigma)^*$. Assim pela construção de $G'$ pode-se então realizar a seguinte derivação:
        $$S \gg^*_{G'} k_1Ak_2 \gg_{G'} k_1x_1y_1x_2k_2  \gg^*_{G'} w$$
        e assim tem-se que, $w \in \mathcal{L}(G')$.
    \end{itemize}
    Logo pelos casos $(1)$ e $(2)$ acima tem-se que $\mathcal{L}(G) \subseteq \mathcal{L}(G')$. Agora mostrar que $\mathcal{L}(G') \subseteq \mathcal{L}(G)$ é trivial e não será feito aqui, e desde que $\mathcal{L}(G) \subseteq \mathcal{L}(G')$ e $\mathcal{L}(G') \subseteq \mathcal{L}(G)$ por definição tem-se que $\mathcal{L}(G) = \mathcal{L}(G')$ o que completa a prova.
\end{proof}

Como pode ser visto no Teorema \ref{teo:SuplificacaoGLC-Sub} e como discutido em \cite{benjaLivro2010} a regra de substituição pode até aumentar o número de regras de reescrita, porém, a mesma também permite que seja realizadas geração mais rápidas, isto é, que aconteçam derivações de palavras $w \in \Sigma^*$ com menos passos.

\begin{example}
    Dado a GLC $G = \langle \{S, A, B, C\}, \{0,1\}, S, P \rangle$ com $P$ definido pelas regras:
    \begin{eqnarray*}
        S & \rhd & A001 \mid B100\\
        A & \rhd & 01 \mid 01B\\
        B & \rhd & 1 \mid 0 \mid \lambda
    \end{eqnarray*}
    aplicando a regra de substituição em tal gramática será gerada na gramática $G' = \langle \{S, A, B, C\}, \{0,1\}, S, P' \rangle$ em que $P'$ corresponde ao conjunto formado pela seguintes regras:
    \begin{eqnarray*}
        S & \rhd & A001 \mid B100 \mid  01001 \mid 01B001 \mid 1100 \mid 0100 \mid 100 011001 \mid 010001 \mid 01001\\
        A & \rhd & 01 \mid 01B \mid 011 \mid  010 \\
        B & \rhd & 1 \mid 0 \mid \lambda
    \end{eqnarray*}
\end{example}

Para prosseguir com o estudo das regras de simplificação antes é necessário formalizar o conceito de variável recursiva à esquerda nas GLC.

\begin{definition}[Regra Recursiva à Esquerda]\label{def:VariavelRecursiva}
    Seja $G = \langle V, \Sigma, S, P\rangle$ uma GLC, uma variável $A$ é dita recursiva à esquerda se existe pelo menos uma regra $A \rhd Ax \in P$ com  $A \in V$ e $x \in (V \cup \Sigma)^*$.
\end{definition}

Agora é possível formalizar então a próxima regra de simplificação de GLC, sendo esta próxima regra nomeada como \textbf{Regra de Remoção da Recursividade Esquerda}.

\begin{definition}[Regra de Remoção da Recursividade Esquerda]\label{def:RegraRecursiva}
    Seja $G = \langle V, \Sigma, S, P\rangle$ uma GLC com variáveis recursivas à esquerda. Então substitua para cada $A \in V$ as regras:
    $$A \rhd Ax_1 \mid \cdots \mid Ax_m \mid y_1 \mid \cdots \mid y_n$$
    pelas regras:
    \begin{eqnarray*}
        A & \rhd & y_1 \mid \cdots \mid y_n \mid y_1Z \mid \cdots \mid y_nZ\\
        Z & \rhd & x_1 \mid \cdots \mid x_m \mid x_1Z \mid \cdots \mid x_mZ
    \end{eqnarray*}
	onde $x_1, \cdots, x_m, y_1, \cdots, y_n \in (V \cup \Sigma)^*$ e $Z$ é uma variável nova que deve ser adicionada ao conjunto $V$.
\end{definition}

Fica claro pela definição da Regra de Remoção da Recursividade Esquerda que após usa aplicação será gerada uma nova gramática com mais varáveis que a gramática original terá uma quantidade igual ou superior de regras de reescritas.

\begin{theorem}\label{teo:SuplificacaoGLC-Rec}
    Se $G = \langle V, \Sigma, S, P\rangle$ é uma GLC, então a gramática $G'$ gerada a partir da regra de remoção da recursividade esquerda é tal que $\mathcal{L}(G) = \mathcal{L}(G')$.
\end{theorem}

\begin{proof}
    Ficará como exercício ao leitor.
\end{proof}

\begin{example}
    Dado a GLC $G = \langle \{S, A\}, \{a,b, c\}, S, P \rangle$ com $P$ definido pelas regras:
    \begin{eqnarray*}
        S & \rhd & aSc \mid aAc\\
        A & \rhd & Ab \mid b
    \end{eqnarray*}
    Usando a regra de remoção da recursividade esquerda é obtida a GLC $G = \langle \{S, A, B\}, \{a, b, c\}, S, P' \rangle$ onde $P'$ é definido por:
    \begin{eqnarray*}
        S & \rhd & aSc \mid aAc\\
        A & \rhd & b \mid bB\\
        B & \rhd & b \mid bB 
    \end{eqnarray*}
\end{example}

Agora para continuar com o estudo das regras de simplificação será necessário formalizar três conceitos chaves, o primeiro conceito é a noção de relação (ou grafo) de dependências, a saber tais relações (ou grafos) são ferramentas advindas da teoria dos grafos e frequentemente usada em muitos campos do conhecimento para modela sistemas complexos \cite{benjaLivro2010}, a seguir este conceito será apresentado de forma rigorosa com respeito as GLC.

\begin{definition}[Relação de dependência]\label{def:GrafoDependencia}
    Seja $G = \langle V, \Sigma, S, P\rangle$ é uma GLC, a relação de dependência $DEP$ é construída como: $(A, B) \in DEP$ se, e somente se, $A \rhd xBy \in P$ com $x, y \in (V \cup \Sigma)^*$ e $A \neq B$.
\end{definition}

O leitor pode considerar a relação $DEP$ como sendo uma relação de necessidade, em que $(A, B) \in DEP$ pode ser semanticamente interpretado como, para escrever $B$ é necessário que antes existem um $A$.

\begin{remark}
    Para fins de notação, será usado o rótulo $\widehat{DEP}$ para denotar o fecho transitivo da relação $DEP$.
\end{remark}

\begin{example}\label{exe:GLCDEP}
    Considere a GLC $G = \langle \{A, B, C, D, E\}, \{0, 1\}, A, P \rangle$ onde $P$ é o conjunto formado pelas regras:
    
    \begin{eqnarray*}
        A & \rhd & 00A \mid 0B1 \mid 10AB \mid AD\\ 
        B & \rhd & 1B01 \mid D01E\mid \lambda\\
        C & \rhd & C01 \mid 00101 \mid 1 \mid \lambda\\
        D & \rhd & 01E \mid 0E\\
        E & \rhd & 1E0 \mid EE \mid D
    \end{eqnarray*}
    Tem-se que $\widehat{DEP}$ é o conjunto formado pelo pares $(A, B), (A, D), (B, D), (B, E), (D, E),$ e $(E, D)$.
\end{example}

O próximo conceito necessário é a noção de variável inacessível formalizado a seguir.

\begin{definition}[Variável inacessível]\label{def:VariavelInacessível}
    Seja $G = \langle V, \Sigma, S, P\rangle$ é uma GLC, uma variável $A \neq S$ é dita ser inacessível sempre que $(S, A) \notin \widehat{DEP}$.
\end{definition}

\begin{example}
    Considere a GLC apresentada no Exemplo \ref{exe:GLCDEP}, em tal gramática é fácil notar que a variável $C$ é inacessível.
\end{example}

\begin{lemma}\label{lema:SemInacessivel}
    Se $G = \langle V, \Sigma, S, P\rangle$ é uma GLC, então existe uma GLC sem variáveis inacessíveis $G' = \langle V', \Sigma, S, P'\rangle$ tal que $\mathcal{L}(G) = \mathcal{L}(G')$.
\end{lemma}

\begin{proof}
    Suponha que $G = \langle V, \Sigma, S, P\rangle$ é uma GLC, assim pode-se construir uma nova GLC $G' = \langle V', \Sigma, S, P'\rangle$ onde: 
    \begin{itemize}
        \item $V' = V - \{A \in V \mid A \mbox{ é uma variável inacessível}\}$ e
        \item $P' = \{A \rhd xBy \in P \mid A, B \in V', x, y \in (V' \cup \Sigma)^*\}$.
    \end{itemize}
    Agora é claro que $G'$ possui apenas variáveis acessíveis. Note agora que para toda $S \gg_G w$ tem-se que apenas regras com variáveis acessíveis são utilizadas em tal derivação, além disso, é claro pela construção de $G'$ que tais regras estarão em $P'$, consequentemente $S \gg_{G'} w$, assim $\mathcal{L}(G) \subseteq \mathcal{L}(G')$. Por outro lado, assuma por absurdo que $\mathcal{L}(G') \not\subseteq \mathcal{L}(G)$, assim existe um $w \in \mathcal{L}(G')$ tal que $w \notin \mathcal{L}(G)$, desde que $w \in \mathcal{L}(G')$ tem-se que $S \gg_{G'} w$, mas pela construção de $G'$ é obvio que toda regra usada na derivação $S \gg_{G'} w$ também estão presente em $P$ e, portanto, $S \gg_{G} w$ o que contradiz a hipótese de que $\mathcal{L}(G') \not\subseteq \mathcal{L}(G)$, consequentemente, tem-se $\mathcal{L}(G') \subseteq \mathcal{L}(G)$. Desde que, $\mathcal{L}(G) \subseteq \mathcal{L}(G')$ e $\mathcal{L}(G') \subseteq \mathcal{L}(G)$, pela definição de igualdade entre conjunto tem-se que $\mathcal{L}(G) = \mathcal{L}(G')$.
\end{proof}

O terceiro e último conceito necessário para continuar com o estudo das regras de simplificação é a ideia de variável descartável em uma GLC, de forma direta uma variável descartável é aquela incapaz de derivar uma palavra sobre o alfabeto $\Sigma$, em notação formal tem-se a definição a seguir.

\begin{definition}[Variável descartável]\label{def:VariavelDescartavel}
    Seja $G = \langle V, \Sigma, S, P\rangle$ é uma GLC, uma variável $A$ é dita descartável sempre que para todo $w \in \Sigma^*$ tem-se que $A \not\gg^* w$.
\end{definition}

\begin{example}
    Considere a GLC apresentada no Exemplo \ref{exe:GLCDEP}, em tal gramática as variáveis $D$ e $E$ são ambas descartáveis.
\end{example}

O leitor um pouco mais experiente em programação pode facilmente notar que uma variável descartável é aquela que é a raiz de uma árvore infinita, isto é, uma árvore que continua crescendo infinitamente, outra forma de interpretar uma variável descartável é como sendo uma variável que produz um \textit{loop} infinito no processo de derivação, ou seja, a partir de tal variável nunca é possível derivar uma palavra sobre o alfabeto base da gramática.

\begin{lemma}\label{lema:SemDescartavel}
    Se $G = \langle V, \Sigma, S, P\rangle$ é uma GLC, então existe uma GLC sem variáveis descartável $G' = \langle V', \Sigma, S, P'\rangle$ tal que $\mathcal{L}(G) = \mathcal{L}(G')$.
\end{lemma}

\begin{proof}
    Suponha que $G = \langle V, \Sigma, S, P\rangle$ é uma GLC, assim pode-se construir uma nova GLC $G' = \langle V', \Sigma, S, P'\rangle$ onde: 
    \begin{itemize}
        \item $V' = V - \{A \in V \mid A \mbox{ é uma variável descartável}\}$ e
        \item $P' = \{A \rhd xBy \in P \mid A, B \in V', x, y \in (V' \cup \Sigma)^*\}$.
    \end{itemize}
    Agora é claro que $G'$ não possui variáveis descartáveis. A argumentação para provar $\mathcal{L}(G) = \mathcal{L}(G')$ é similar a demonstração do Lema \ref{lema:SemInacessivel}.
\end{proof}

\begin{definition}[Regra de remoção de variáveis inúteis]\label{def:RegraInuteis}
    Dado uma GLC $G = \langle V, \Sigma, S, P\rangle$ será gerada uma gramática $G'$ sem variáveis inúteis, após a execução dos seguintes passos.
    \begin{enumerate}
        \item Remova todas as variáveis Descartáveis e assim gere uma gramática $G_1$.
        \item Remova da gramática $G_1$ todas as variáveis Inacessíveis, e assim gere a gramática $G'$.
    \end{enumerate}
\end{definition}

O termo inútil diz respeito ao fato de uma variável $A$ não ser capaz de derivar uma palavra $w \in \Sigma^*$, ou seja, $A \not\gg_G w$.

\begin{theorem}\label{teo:SemVariaveisInuteis}
    Se $G = \langle V, \Sigma, S, P\rangle$ é uma GLC, então a GLC $G'$ gerada pela regra de remoção de variáveis inúteis é tal que $\mathcal{L}(G) = \mathcal{L}(G')$.
\end{theorem}

\begin{proof}
    Direto dos Lemas \ref{lema:SemInacessivel} e \ref{lema:SemDescartavel}.
\end{proof}

O exemplo a seguir ilustra a aplicação da regra de remoção de variáveis inúteis.

\begin{example}
    Considere a GLC $G = \langle \{S, T, V, X, Y, Z\}, \{0, 1\}, S, P \rangle$ onde $P$ é o conjunto com as seguintes produções:
    \begin{eqnarray*}
        S & \rhd & 01S \mid SX0 \mid YZ \mid X0Z11\\
        T & \rhd & \lambda\\
        X & \rhd & X01 \mid Y0X\\
        Y & \rhd & S01 \mid YY \mid XY \mid \lambda\\
        Z & \rhd & S01 \mid SS
    \end{eqnarray*}
    Removendo as variáveis descartáveis (neste caso existe apenas variável $X$ a ser removida)  é gerado a GLC $G_1 = \langle \{S, T, V, Y, Z\}, \{0, 1\}, S, P_1 \rangle$ com $P_1$ sendo:
    \begin{eqnarray*}
        S & \rhd & 01S \mid YZ \\
        T & \rhd & \lambda\\
        Y & \rhd & S01 \mid YY \mid \lambda\\
        Z & \rhd & S01 \mid SS
    \end{eqnarray*}
    Agora trabalhando considerando o conjunto $P_1$ pode-se remover as variáveis inacessíveis, ou seja, são removidas as variáveis $T, V$ e assim tem-se como resultado final da remoção de variáveis inúteis é gerada a GLC $G' = \langle \{S, Y, Z\}, \{0, 1\}, S, P' \rangle$ onde $P'$ é formado por:
    \begin{eqnarray*}
        S & \rhd & 01S \mid YZ \\
        Y & \rhd & S01 \mid YY \mid \lambda\\
        Z & \rhd & S01 \mid SS
    \end{eqnarray*}
\end{example}

\begin{definition}
    Seja $G = \langle V, \Sigma, S, P\rangle$ é uma GLC, uma regra da forma $A \rhd \lambda$ é chamada de $\lambda$-produção. 
\end{definition}

O próximo resultado estabelece que em GLC a existência de $\lambda$-produções não aumenta o poder gerativo das gramáticas.

\begin{theorem}\label{teo:SemLambdaProducoes}
    Se $G = \langle V, \Sigma, S, P\rangle$ é uma GLC, então existe uma GLC $G'$ sem $\lambda$-produções tal que $\mathcal{L}(G) = \mathcal{L}(G')$.
\end{theorem}

\begin{proof}
    Suponha que $G = \langle V, \Sigma, S, P\rangle$ é uma GLC, agora defina os conjuntos 
    \begin{eqnarray*}
        P_1  & = &  P - \{A \rhd \lambda \mid A \in V\}\\
        V_\lambda & = &  \{A \in V \mid A \rhd \lambda\}
    \end{eqnarray*}
    Pode-se agora construir um novo conjunto de regras $P_2$ da seguinte forma,  para cada uma das regras
    $$A \rhd w_1A_1w_2A_2w_3\cdots w_{n-1}A_{n-1}w_{n}A_nw_{n+1} \in P_1$$
    com $w_i \in (V \cup \Sigma)^*, A_j \in V_\lambda$ sendo $1 \leq i \leq n+1$ e $1 \leq j \leq n$ estarão em $P_2$ as regras:
    \begin{eqnarray*}
        A & \rhd & w_1w_2A_2w_3\cdots w_{n-1}A_{n-1}w_{n}A_nw_{n+1}\\
        A & \rhd & w_1A_1w_2w_3\cdots w_{n-1}A_{n-1}w_{n}A_nw_{n+1}\\
        \vdots & \vdots & \hspace{2.7cm} \vdots\\
        A & \rhd & w_1A_1w_2A_2w_3\cdots w_{n-1}w_{n}A_nw_{n+1}\\
        A & \rhd & w_1A_1w_2A_2w_3\cdots w_{n-1}A_{n-1}w_{n}w_{n+1}\\
        A & \rhd & w_1w_2w_3\cdots w_{n-1}w_{n}w_{n+1} 
    \end{eqnarray*}
    Finalmente defina a GLC $G' = \langle V, \Sigma, S, P' \rangle$ em que $P' = P_1 \cup P_2$, é claro por sua construção que $P'$ não possui $\lambda$-produções. Agora assuma que $w \in \mathcal{L}(G)$, ou seja, $S \gg_G^* w$, dessa forma há dois casos para serem considerados:
    \begin{itemize}
        \item[(1)] Se durante a derivação $S \gg_G^* w$ não forem usadas regras da forma $A \rhd \lambda$, então obviamente essa mesma derivação pode ser replicada em todos os seu detalhes na gramática $G'$, uma vez que, todas as regras que não são da forma $A \rhd \lambda$ estão também em $P'$, assim $S \gg_{G'}^* w$, consequentemente, $w \in \mathcal{L}(G')$.
        \item[(2)] Agora sem perda de generalidade assuma que pelo menos uma regra da forma  $A \rhd x_1Bx_2$ seguida da regra $B \rhd \lambda$ aparecem na derivação $S \gg_G^* w$, portanto, tem-se que:
        $$S \gg_G^* k_1Ak_2 \gg_{G} k_1x_1Bx_2k_2 \gg_{G} k_1x_1x_2k_2 \gg^*_G w $$
        com $k_1, k_2, x_1, x_2,  \in (V \cup \Sigma)^*$. Assim pela construção de $G'$ existe uma regra da forma $A \rhd x_1x_2$ e, portanto, em $G'$ é possível realizar a seguinte derivação
        $$S \gg_G^* k_1Ak_2 \gg_{G'} k_1x_1x_2k_2 \gg^*_G w $$
        e assim tem-se que $w \in \mathcal{L}(G')$.
    \end{itemize}
    Assim pelos casos $(1)$ e $(2)$ mostrados acima tem-se que $\mathcal{L}(G) \subseteq \mathcal{L}(G')$. Por outro lado, mostrar que $\mathcal{L}(G') \subseteq \mathcal{L}(G)$ é trivial e ficará como exercício ao leitor. Desde que $\mathcal{L}(G) \subseteq \mathcal{L}(G')$ e $\mathcal{L}(G') \subseteq \mathcal{L}(G)$ por definição de igualdade de conjuntos tem-se que $\mathcal{L}(G) = \mathcal{L}(G')$.
\end{proof}

\begin{example}
    Dado a gramática $G = \langle \{S, X, Y, Z\}, \{a, b, c\}, S, P \rangle$ com $P$ sendo o conjunto com as seguintes regras,
    \begin{eqnarray*}
        S & \rhd & Xca \mid bYa \mid aZXcb \\
        X & \rhd & bbXY \mid ZacYb \mid abYcZa \\
        Y & \rhd & cYcaYX \mid \lambda\\
        Z & \rhd & abc \mid \lambda
    \end{eqnarray*}
    utilizando a estratégia usada na prova do Teorema \ref{teo:SemLambdaProducoes}, tem-se o seguinte conjunto $P_1$ de regras, 
    \begin{eqnarray*}
        S & \rhd & Xca \mid bYa \mid aZXcb \\
        X & \rhd & bbXY \mid ZacYb \mid abYcZa \\
        Y & \rhd & cYcaYX\\
        Z & \rhd & abc
    \end{eqnarray*}
    já o conjunto $P_2$ corresponde ao seguinte conjunto,
    \begin{eqnarray*}
        S & \rhd & Xca \mid ba \mid aXcb \\
        X & \rhd & bbX \mid acYb \mid Zacb \mid acb \mid abYcZa \mid abcZa \mid abYca \mid abca \\
        Y & \rhd & cYcaYX \mid ccaYX \mid cYcaX \mid ccaX \\
        Z & \rhd & abc
    \end{eqnarray*}
    por fim, é construído a gramática  $G = \langle \{S, X, Y, Z\}, \{a, b, c\}, S, P' \rangle$ onde $P'$ é o conjunto com as seguintes regras,
    \begin{eqnarray*}
        S & \rhd & Xca \mid bYa \mid aZXcb \mid ba \mid aXcb \\
        X & \rhd & bbXY \mid ZacYb \mid abYcZa \mid bbX \mid acYb \mid Zacb \mid acb \mid abcZa \mid abYca \mid abca  \\
        Y & \rhd & cYcaYX \mid ccaYX \mid cYcaX \mid ccaX  \\
        Z & \rhd & abc
    \end{eqnarray*}
\end{example}

Entre os diferentes tipo de regras em uma gramática, existe o tipo chamado de regras unitárias definidas a seguir, tais regras tem a natureza de não gerar qualquer símbolo do alfabeto, e essa natureza muitas vezes não é desejável como dito em \cite{benjaLivro2010}, a seguir será mostrado que tais regras não aumentam o poder gerativo das GLC.

\begin{definition}[Regras unitárias]\label{def:RegraUnitaria}
    Seja $G = \langle V, \Sigma, S, P\rangle$ é uma GLC, um elemento de $P$ é chamado de regra unitária sempre que tal elemento for da forma $A \rhd B$ com $A, B \in V$.
\end{definition}

\begin{theorem}\label{teo:SemProducoesUnitarias}
    Se $G = \langle V, \Sigma, S, P\rangle$ é uma GLC com regras unitárias, então existe uma GLC $G' = \langle V, \Sigma, S, P'\rangle$ sem regras unitárias tal que $\mathcal{L}(G) = \mathcal{L}(G')$.
\end{theorem}

\begin{proof}
    Suponha que $G = \langle V, \Sigma, S, P\rangle$ é uma GLC com regras unitárias, assim construa o seguinte conjunto de regras,
    $$P_1 = \{A \rhd xBy \in P \mid |x| + |y| \geq 1, B \in V\}$$
    agora construa o conjunto de regras,
    $$P_2 = \{A \rhd w \mid A \gg^*_G B, B \rhd w \in P_1\}$$
    é fácil notar que $P_1$ e $P_2$ não possuem regras unitárias. Por fim, defina a GLC $G' = \langle V, \Sigma, S, P'\rangle$ onde $P' = P_1 \cup P_2$.  A argumentação para provar $\mathcal{L}(G) = \mathcal{L}(G')$ é similar a demonstração do Teorema \ref{teo:SemLambdaProducoes}.
\end{proof}

A seguir para melhor fixação do conhecimento o leitor encontrará no próximo exemplo o uso da construção esboçada na prova do Teorema \ref{teo:SemProducoesUnitarias}.

\begin{example}
    Dado a gramática $G = \langle \{S, X, Y, Z\}, \{0, 1\}, S, P \rangle$ com $P$ sendo o conjunto com as seguintes regras,
    \begin{eqnarray*}
        S & \rhd & 0X \\
        X & \rhd & Y \mid 0X \\
        Y & \rhd & Z \mid 1Y \mid YY\\
        Z & \rhd & Y \mid 01
    \end{eqnarray*}
    agora utilizando a estratégia apresentada na prova do Teorema \ref{teo:SemProducoesUnitarias} tem-se que $P_1$ é formado pelas seguintes regras, 
    \begin{eqnarray*}
        S & \rhd & 0X \\
        X & \rhd & 0X \\
        Y & \rhd & 1Y \mid YY\\
        Z & \rhd & 01
    \end{eqnarray*}
    e assim o conjunto $P_2$ é formado pelas regras
    \begin{eqnarray*}
        X & \rhd & 1Y \mid YY \mid 01 \\
        Y & \rhd & 01 \\
        Z & \rhd & 1Y \mid YY
    \end{eqnarray*}
    por fim, é construído a gramática  $G = \langle \{S, X, Y, Z\}, \{a, b, c\}, S, P' \rangle$ onde $P'$ é o conjunto com as seguintes regras,
    \begin{eqnarray*}
        S & \rhd & 0X \\
        X & \rhd & 0X \mid 1Y \mid YY \mid 01 \\
        Y & \rhd & 1Y \mid YY \mid 01\\
        Z & \rhd & 01 \mid 1Y \mid YY
    \end{eqnarray*}
\end{example}

Agora que foram apresentadas as estratégia de simplificação de gramática este manuscrito pode prosseguir para a apresentação do conceito de normalização de gramática. Como explicado em \cite{menezes1998LFA}, uma normalização consiste de estabelecer um ou mais  padrões (ou restrições) que \textbf{todas as regras} de reescrita da gramática devem obedecer. As duas principais formas normais para as GLC são como dito em  \cite{benjaLivro2010}, a forma normal de Chomsky \cite{chomsky1959} e a forma normal de Greibach \cite{greibach1965}.

Vale ressaltar que nos dias atuais no estudo das linguagens formais é comum adotar uma definição reduzida\footnote{A diferença entre a forma reduzida e forma normal introduzida por Chomsky em \cite{chomsky1959}, é que a versão original do paper permitia a existência da regra $S \rhd \lambda$.} da forma normal de Chomsky como podem ser visto em \cite{benjaLivro2010, hopcroft2008, menezes1998LFA}, assim seguindo o padrão atual do estudo das linguagens formais e autômatos esse manuscrito também irá adotar a versão reduzida.

\begin{definition}[Forma normal de Chomsky]\label{def:NormalChomsky}
    Uma GLC $G = \langle V, \Sigma, S, P \rangle$ está na forma normal Chomsky se para todo $\alpha \rhd \beta \in P$ tem-se que $\beta = AB$ ou $\beta = a$ com $A, B \in V$ e $a \in \Sigma$.
\end{definition}

\begin{remark}
    É evidente pela própria definição que GLC na forma normal de Chomsky não possuem $\lambda$-produções e nem regras unitárias.
\end{remark}

Antes de apresentar o algoritmo capaz de converter qualquer GLC em sua equivalente na forma normal de Chomsky é conveniente apresentar a definição e os resultados a seguir.

\begin{definition}[Forma normal de pré-Chomsky]\label{def:NormalPreChomsky}
    Uma GLC $G = \langle V, \Sigma, S, P \rangle$ está na forma normal pré-Chomsky se para todo $\alpha \rhd \beta \in P$ tem-se que $\beta = A_1\cdots A_m$ ou $\beta = a$ com $A_i \in V, a \in \Sigma$ sendo $1 \leq i \leq m$.
\end{definition}

\begin{lemma}\label{lema:PreChomsky}
    Se $G = \langle V, \Sigma, S, P \rangle$ é uma GLC, então existe uma GLC $G'$ na forma normal pré-Chomsky tal que $\mathcal{L}(G) = \mathcal{L}(G')$.
\end{lemma}

\begin{proof}
    Assuma sem perda de generalidade que $G = \langle V, \Sigma, S, P \rangle$ é uma GLC sem $\lambda$-produções, assim toda regra $\alpha \rhd \beta \in P$ é tal que $\beta = w_1A_1 \cdots w_{n}A_{n}w_{n+1}$ com $w_i \in \Sigma^*$ e $A_j \in V \cup \{\lambda\}$ e $|w_1A_1 \cdots w_{n}A_{n}w_{n+1}| \geq 1$ sendo que $1 \leq i \leq n+1$ e $1 \leq j \leq n$. Agora construa um novo conjunto de variáveis da forma $V_\Sigma = \{A_a \mid a \in \Sigma\}$, assim é claro a existência de isomorfismo $h: \Sigma^* \rightarrow V_\Sigma^*$ definido recursivamente para todo $w \in \Sigma^*$ e $a \in \Sigma$ como sendo:
    \begin{eqnarray*}
        h(\lambda) & = & \lambda\\
        h(wa) & = & h(w)A_a
    \end{eqnarray*}
    agora defina uma nova gramática $G' = \langle V', \Sigma, S, P' \rangle$ onde $V' = V \cup V_\Sigma$ e $P' = P_h \cup P_\Sigma$ onde, 
    $$P_h = \{\alpha \rhd h(w_1)A_1 \cdots h(w_{n})A_{n}h(w_{n+1}) \mid \alpha \rhd w_1A_1 \cdots w_nA_{n}w_{n+1} \in P, |n+1| \geq 2\}$$
    e
    $$P_\Sigma = \{A_a \rhd a \mid A_a \in V_\Sigma\}$$
    consequentemente, todo $\alpha' \rhd \beta' \in P'$ é tal que $\beta' = X_1\cdots X_n$ ou $\beta' = a$ com $X_k \in V'$ e $a \in \Sigma \cup \{\lambda\}$ com $1 \leq k \leq n$ e $|X_1\cdots X_n| \geq 1$, assim por definição tem-se que $G'$ está na forma normal pré-Chomsky. Agora para mostrar que $\mathcal{L}(G) = \mathcal{L}(G')$  basta usar um argumento similar aos utilizados nas demonstrações dos Lemas \ref{lema:SemInacessivel} e \ref{lema:SemDescartavel} e dos Teoremas \ref{teo:SuplificacaoGLC-Sub},  \ref{teo:SemLambdaProducoes} e \ref{teo:SemProducoesUnitarias}.
\end{proof}

\begin{theorem}\label{teo:NormalChomsky}
    Se $G = \langle V, \Sigma, S, P \rangle$ é uma GLC, então existe uma GLC $G'$ na forma normal de Chomsky tal que $\mathcal{L}(G) = \mathcal{L}(G')$.
\end{theorem}

\begin{proof}
    Assuma sem perda de generalidade que $G = \langle V, \Sigma, S, P \rangle$ é uma GLC assim pelo Lema \ref{lema:PreChomsky} existe uma GLC na forma normal pré-Chomsky $\widehat{G} = \langle \widehat{V}, \Sigma, S, \widehat{P} \rangle$ tal que $\mathcal{L}(G) = \mathcal{L}(\widehat{G})$, e como pode ser notado na demonstração do  Lema \ref{lema:PreChomsky} todas as regras em $\widehat{P}$ serão das forma:
    \begin{itemize}
        \item $A \rhd A_1 \cdots A_n$ ou 
        \item $A \rhd a$
    \end{itemize}
    com $A, A_i \in \widehat{V}$ e $a \in \Sigma$ para cada $1 \leq i \leq n$. Agora defina os seguintes conjuntos disjuntos:
    \begin{itemize}
        \item $P_{1} = \{A \rhd w \in P \mid |w| \leq 2\}$
        \item $P_{2} = P - P_{1}$
    \end{itemize}
    agora considere um conjunto de variáveis $V_1$ inicialmente vazio, além disso,  construa um conjunto $P_3$ da seguinte forma, para cada $A \rhd A_1A_2\cdots a_m \in P_2$ as regras:
    \begin{eqnarray*}
        A & \rhd & A_1X_1\\
        X_1 & \rhd & A_2X_2\\
        \vdots & \vdots & \vdots\\
        X_{m-2} & \rhd & A_{m-1}A_{m}
    \end{eqnarray*}
    são elementos de $P_3$ e $X_i$ é uma nova variável adicionada ao conjunto $V_1$ com $i \leq m-2$. Agora construa uma gramática $G' = \langle V', \Sigma, S, P' \rangle$ onde $V' = V_1 \cup V$ e $P' = P_1 \cup P_3$, é fácil ver que todas as regras em $P'$ satisfazem as condições da forma normal de Chomsky, assim $G'$ está na forma normal de Chomsky. Por fim, não é difícil verificar que para toda palavra $w \in \Sigma$ tem-se que $S \gg^*_{\widehat{G}} w$ se, e somente se, $S \gg^*_{G'} w$,  consequentemente,  $\mathcal{L}(G) = \mathcal{L}(G')$.
\end{proof}

Para que leitores com menos facilidade com a linguagem matemática possam entender os procedimentos para encontrar a forma normal de Chomsky de uma GLC dada, agora serão convertidos os procedimentos usados nas demonstrações do Lema \ref{lema:PreChomsky} e do Teorema \ref{teo:NormalChomsky} em dois algoritmos.

\begin{algorithm}[h]
	\Entrada{Uma GLC $G = \langle V, \Sigma, S, P \rangle$}
	\Saida{Uma GLC $G' = \langle V', \Sigma, S, P' \rangle$ na forma normal pré-Chomsky}
	\Inicio{
	    Se existirem remova as $\lambda$-produções\\
		Se existirem remova as regras unitárias\\
		Inicialize o conjunto $V'$ sendo igual a $V$\\
		Inicialize o conjunto $P'$ como sendo vazio\\
		\ParaCada{$a \in \Sigma$}{
		    Adicione em $V'$ a variável $A_a$\\
		    Adicione em $P'$ a regra $A_a \rhd a$\\
		    \Se{$A \rhd a \in P$ com $A \in V$}{
		        Adicione em $P'$ a regra $A\rhd a$\\
		    }
		}
		\ParaCada{$\alpha \rhd \beta \in P$ com $|\beta| \geq 2$}{
		    \eSe{$\exists a \in \Sigma$ em $\beta$}{
		        Gere $\beta'$ trocando cada $a \in \Sigma$ de $\beta$ por $A_a$\\
		        Adicione em $P'$ a regra $\alpha \rhd \beta'$\\
		    }{
		        Adicione em $P'$ a regra $\alpha \rhd \beta$\\
		    }
	    }
	    \Retorna{$G' = \langle V', \Sigma, S, P' \rangle$}
	}
	\caption{Algoritmo para construir uma GLC na forma normal pré-Chomsky.}
	\label{alg:GLC-FNpreChomsky}
\end{algorithm}

\begin{remark}
    O leitor atento pode notar que a implementação do isomorfismo $h$ descrito na demonstração do Lema \ref{lema:PreChomsky} corresponde exatamente ao trecho de código entre as linhas 14 e 19 do Algoritmo \ref{alg:GLC-FNpreChomsky}.
\end{remark}
\newpage

\begin{algorithm}[h]
	\Entrada{Uma GLC $G = \langle V, \Sigma, S, P \rangle$}
	\Saida{Uma GLC $G' = \langle V', \Sigma, S, P' \rangle$ na forma normal de Chomsky}
	\Inicio{
		Use $G$ como entrada do Algoritmo \ref{alg:GLC-FNpreChomsky} e obtenha $\widehat{G} = \langle \widehat{V}, \Sigma, S, \widehat{P} \rangle$\\
		Inicialize o conjunto $V'$ sendo igual a $\widehat{V}$\\
		Inicialize o conjunto $P'$ como sendo vazio\\
		\ParaCada{$\alpha \rhd \beta \in \widehat{P}$ com $|\beta| \leq 2$}{
		    Adicione a regra $\alpha \rhd \beta$ no conjunto $P'$\\
		}
		\ParaCada{$\alpha \rhd A_1A_2A_3\cdots A_n \in \widehat{P}$ com $n \geq 3$}{
		    Adicione variáveis novas $X_1, \cdots, X_{n-1}$ em $V'$\\
		    Adicione em $P'$ as regras $\alpha \rhd A_1X_1, X_1 \rhd A_2X_2, \cdots, X_{n-2} \rhd A_{n-1}A_n$\\
		}
		\Retorna{$G' = \langle V', \Sigma, S, P' \rangle$}
	}
	\caption{Algoritmo para construir uma GLC na forma normal de Chomsky.}
	\label{alg:GLC-FNChomsky}
\end{algorithm}

\begin{example}
    A GLC na forma normal de Chomskya obtida a partir da GLC $G = \langle \{S, A, B, C, D\}, \{0,1\}, S, P \rangle$ com $P$ sendo formado pelas seguintes regras:
    \begin{eqnarray*}
        S & \rhd & 0AB \mid C1D \mid 011 \mid 100\\
        A & \rhd & 1A00 \mid 11B \mid CA0\\
        B & \rhd & 0S \mid C1S \mid \lambda\\
        C & \rhd & 11C \mid B01 \mid \lambda\\
        D & \rhd & 101 \mid \lambda
    \end{eqnarray*}
    è construída aplicando primeiro o Algoritmo \ref{alg:GLC-FNpreChomsky} sobre a gramática $G$, assim inicialmente o algoritmo remove as $\lambda$-produções gerado um conjunto de regras temporário da forma,
    \begin{eqnarray*}
        S & \rhd & 0AB \mid C1D \mid 011 \mid 100 \mid 0A \mid C1 \mid 1D \mid 1\\
        A & \rhd & 1A00 \mid B11 \mid 0CA \mid 11 \mid 0A\\
        B & \rhd & 0S \mid C1S \mid 1S\\
        C & \rhd & 11C \mid B01 \mid 11 \mid 01\\
        D & \rhd & 101
    \end{eqnarray*}
    como não produções unitárias no conjunto de regras acima o Algoritmo \ref{alg:GLC-FNpreChomsky} inicializa o conjunto $V' = \{S, A, B, C, D\}$ e cria e insere em $V'$ as varáveis $A_0$ e $A_1$, ou seja, tem-se agora que $V' = \{S, A, B, C, D, A_0, A_1\}$ e são adicionados as regras  $A_0 \rhd 0$ e $A_1 \rhd 1$ no conjunto de regras temporário, ou seja, tal conjunto fica da forma,
    \begin{eqnarray*}
        S & \rhd & 0AB \mid C1D \mid 011 \mid 100 \mid 0A \mid C1 \mid 1D \mid 1\\
        A & \rhd & 1A00 \mid B11 \mid 0CA \mid 11 \mid 0A\\
        B & \rhd & 0S \mid C1S \mid 1S\\
        C & \rhd & 11C \mid B01 \mid 11 \mid 01\\
        D & \rhd & 101\\
        A_0 & \rhd & 0 \\
        A_1 & \rhd & 1
    \end{eqnarray*}
    agora para cada regra $\alpha \rhd \beta$ em que $|\beta| \geq 2$ são trocados os símbolos $a \in \{0,1\}$ de $\beta$ pelas variáveis correspondentes $A_a$, ou seja, o conjunto de regras passa a ter a forma, 
    \begin{eqnarray*}
        S & \rhd & 0AB \mid CA_1D \mid A_0A_1A_1 \mid A_1A_0A_0 \mid A_0A \mid CA_1 \mid A_1D \mid 1\\
        A & \rhd & A_1AA_0A_0 \mid BA_1A_1 \mid A_0CA \mid A_1A_1 \mid A_0A\\
        B & \rhd & A_0S \mid CA_1S \mid A_1S\\
        C & \rhd & A_1A_1C \mid BA_0A_1 \mid A_1A_1 \mid A_0A_1\\
        D & \rhd & A_1A_0A_1\\
        A_0 & \rhd & 0 \\
        A_1 & \rhd & 1
    \end{eqnarray*}
    neste ponto o conjunto temporário de regras já está na forma pré-Chomsky, pode-se então usar o Algoritmo \ref{alg:GLC-FNChomsky}, que irá conservar as regras da forma $\alpha \rhd w$ com $|w| \leq 2$, e  para cada regra $\alpha \rhd A_1A_2A_3\cdots A_n$ com $n \geq 3$ irá criar e adicionar a $V'$ novas variáveis $X_1, X_{n-1}$ e no conjunto de regras serão inseridas as regras $\alpha \rhd A_1X_1, X_1 \rhd A_2X_2, \cdots, X_{n-2} \rhd A_{n-1}A_n$, assim o conjunto de regras passa a ser da forma,
    
    \begin{eqnarray*}
        S & \rhd & 0X_1 \mid CX_2 \mid A_0X_3 \mid A_1X_4 \mid A_0A \mid CA_1 \mid A_1D \mid 1\\
        X_1 & \rhd & AB \\
        X_2 & \rhd & A_1D\\
        X_3 & \rhd & A_1A_1\\
        X_4 & \rhd & A_0A_0\\
        A & \rhd & A_1X_5 \mid BX_3 \mid A_0X_6 \mid A_1A_1 \mid A_0A\\
        X_5 & \rhd & AX_4\\
        X_6 & \rhd & CA\\
        B & \rhd & A_0S \mid CY_1 \mid A_1S\\
        Y_1 & \rhd & A_1S\\
        C & \rhd & A_1Y_2 \mid BY_3 \mid A_1A_1 \mid A_0A_1\\
        Y_2 & \rhd & A_1C\\
        Y_3 & \rhd & A_0A_1\\
        D & \rhd & A_1Y_3\\
        A_0 & \rhd & 0 \\
        A_1 & \rhd & 1
    \end{eqnarray*}
    
    agora tem-se claramente que a gramática com tal conjunto de regras será uma GLC que está na forma normal de Chomsky. 
\end{example}

%Assim como no livro \cite{benjaLivro2010} este manuscrito segue seu desenvolvimento apresentado ao leitor a definição da forma normal de Greibach.

\begin{definition}[Forma Normal Reduzida de Greibach]
    Uma GLC $G = \langle V, \Sigma, S, P \rangle$ está na forma normal reduzida de Greibach se todas as regras em $P$ tem a forma $A \rhd aB$ com $A \in V, a \in \Sigma$ e $B \in V^*$.
\end{definition}

O leitor atendo pode notar que as gramáticas na forma normal de Greibach possuem a propriedade de que a cada derivação um símbolo da palavra que se quer gerar é inserido na forma sentencial que é construída pelo passo da derivação, assim nas GLC na forma normal de Greibach existe a garantia de que sempre serão necessários \textbf{exatamente} $|w|$ passos de derivação para gerar $w$, o que contrasta com as GLC na forma normal de Chomsky é que se sabe que para gerar $w$ as derivações terão \textbf{no mínimo} $|w|$ passos, nesse sentido, pode-se dizer que as GLC na forma normal de Greibach são mais eficientes que as GLC na forma normal de Chomsky.

\begin{example}\label{exe:GLC-Para_Converter}
    A GLC $G = \langle \{S, T, U\}, \{a, b\}, S, P \rangle$ onde $P$ é definido pelas regras,
    \begin{eqnarray*}
        S & \rhd & TU\\
        T & \rhd & US \mid b\\
        U & \rhd & ST \mid a
    \end{eqnarray*}
    está na forma normal de Chomsky mas não está na forma normal de Greibach.
\end{example}

\begin{example}\label{exe:FazerNoExercicioGLC}
    A GLC $G = \langle \{A, B, C\}, \{a, b\}, A, P \rangle$ onde $P$ é definido pelas regras,
    \begin{eqnarray*}
        A & \rhd & aC \mid a\\
        B & \rhd & b\\
        C & \rhd & aABB
    \end{eqnarray*}
    está na forma normal de Greibach.
\end{example}

\begin{theorem}
    Se $G = \langle V, \Sigma, S, P \rangle$ é uma GLC na forma normal de Greibach, então existe uma GLC $G'$ na forma normal de Chomsky tal que $\mathcal{L}(G) = \mathcal{L}(G')$.
\end{theorem}

\begin{proof}
    Suponha que $G = \langle V, \Sigma, S, P \rangle$ é uma GLC na forma normal de Greibach, consequentemente todas as produções são da forma $A \rhd aB$ com $A \in V, B \in V^*$ e $a \in \Sigma$, agora construa os conjuntos, 
    \begin{itemize}
        \item $V' = V \cup \{A_a \mid a \in \Sigma\}$
        \item $P_1 = \{A \rhd a \in P \mid a \in \Sigma\}$
        \item $P_2 = P - P_1$
        \item $P_3 = \{A \rhd A_aB \mid A \rhd aB \in P_2\}$
    \end{itemize}
    em seguida faça $G'' = \langle V', \Sigma, S, P' \rangle$ tal que $P' = P_1 \cup P_3$, agora claramente tem-se que $G''$ está na forma normal pré-Chomsky e com o mesmo argumento usado na prova do Teorema \ref{teo:NormalChomsky} é possível construir uma GLC $G'$ na forma normal de Chomsky tal que $\mathcal{L}(G) = \mathcal{L}(G')$.
\end{proof}


\begin{theorem}\label{teo:FNGreibach}
    Se $G = \langle V, \Sigma, S, P \rangle$ é uma GLC, então existe uma GLC $G'$ na forma normal Greibach tal que $\mathcal{L}(G) = \mathcal{L}(G')$.
\end{theorem}

O Teorema \ref{teo:FNGreibach} diz que qualquer GLC pode ser convertida para a forma normal de Greibach, neste manuscrito não será apresentado a demonstração do Teorema \ref{teo:FNGreibach}, caso o leitor tenha interesse em tal demonstração é sugerida a leitura de \cite{andrzej1984, benjaLivro2010, greibach1965, menezes1998LFA}. 

\begin{corollary}
	Se $G = \langle V, \Sigma, S, P \rangle$ é uma GLC na forma normal de Chomsky, então existe uma GLC $G'$ na forma normal Greibach tal que $\mathcal{L}(G) = \mathcal{L}(G')$.
\end{corollary}

\begin{proof}
    Trivial.
\end{proof}

A seguir é apresentado o Algoritmo que converte as GLC para a forma normal de Greibach.

\begin{algorithm}[!ht]
	\Entrada{Uma GLC $G = \langle V, \Sigma, S, P \rangle$ na forma normal pré-Chomsy}
	\Saida{Uma GLC $G' = \langle V', \Sigma, S, P' \rangle$ na forma normal de Chomsky}
	\Inicio{
		Renomear as variáveis em $V$ para $A_1, \cdots, A_{\#V}$ de forma que $S$ seja renomeada como $S_1$\\
		Defina os três conjuntos $P_0 = \{A_r \rhd aB \in P \mid a \in \Sigma, B \in V^*\}$, $P_1 = P - P_0$ e $V' = V$\\
	    \Para{$i$ de $1$ até $\#V$}{
	        Defina $j = 1$\\
	        \Enqto{$j < i$}{
	            \ParaCada{$A_i \rhd A_jB \in P_1$}{
	                Remova $A_i \rhd A_jB$ de $P_1$\\   
    	            \ParaCada{$A_j \rhd w \in P_0 \cup P_1$}{
    	                \eSe{$w$ começa com algum $a \in \Sigma$}{
    	                    Adicione $A_i \rhd wB$ em $P_0$\\
    	                }{
    	                    Adicione $A_i \rhd wB$ em $P_1$\\
    	                }
	                }
	            }
	            Incremente o valor de $j$ em 1\\
	        }
	        \Se{$A_i$ possui regras recursivas a esquerda}{
	            Adicione $Z_i$ em $V'$\\
	            Remova a recursão à esquerda de $A_i$s, onde a variável $Z$ descrita na Definição \ref{def:RegraRecursiva} é substituída por $Z_i$ e todas as regras iniciadas com $a \in \Sigma$ são postas em $P_0$ e as demais em $P_1$
	        }
	    }
	    \Para{$i$ de $\#V - 1$ até 1}{
	        Remova de $P_1$ todas as regras $A_i \rhd A_jB$ com $A_j \in V'$ e $B$ sendo uma palavra sobre $V'$\\ 
	        \ParaCada{$A_j \rhd aC \in P_0$ onde $a \in \Sigma$ e $C$ sendo uma palavra sobre $V'$}{
	            Adicione em $P_0$ a regra $A_i \rhd aCB$
	        }
	    }
	    \ParaCada{$Z_i \in V'$ com $i \in \{1, \cdots, \#V\}$}{
	        Remova de $P_1$ todas as regras $Z_i \rhd A_jB$ com $A_j \in V'$ e $B$ sendo uma palavra sobre $V'$\\ 
	        \ParaCada{$A_j \rhd aC \in P_0$ onde $a \in \Sigma$ e $C$ sendo uma palavra sobre $V'$}{
	            Adicione em $P_1$ a regra $Z_i \rhd aCB$
	        }
	    }
	    Defina $P' = P_0 \cup P_1$\\
		\Retorna{$G' = \langle V', \Sigma, A_1, P' \rangle$}
	}
	\caption{Algoritmo para construir uma GLC na forma normal de Greibach.}
	\label{alg:GLC-FNGreibach}
\end{algorithm}

\

\newpage
\begin{example}
    Considere a GLC do Exemplo \ref{exe:GLC-Para_Converter}, a mesma já está na forma normal de Chomsky e, portanto, está na forma normal pré-Chomsky, assim a mesma pode ser aplicada sem problemas ao Algoritmo \ref{alg:GLC-FNGreibach}, supondo que no passo dois o algoritmo renomeou as variáveis da seguinte forma, $S = A_1, T = A_2$ e $U = A_3$, o algoritmo segue construindo então os conjuntos, 
    $$P_0 = \{A_2\rhd b, A_3 \rhd a\}$$
    e
    $$P_1 = \{A_1 \rhd A_2A_3, A_2 \rhd A_3A_1, A_3 \rhd A_1A_2\}$$
    e também, 
    $$V' = \{A_1, A_2, A_3\}$$
    o algoritmo entra agora na execução do \textit{loop} da linha $4$, nas primeiras interações não são efetuadas mudanças nos conjuntos $P_0$ e $P_1$, porém na terceira interação, isto é, quando $i = 3$ tem-se que durante o \textit{loop} interno, iniciado na linha $6$ é encontrada a regra $A_3 \rhd A_1A_2$ em $P_0$ sendo excluída em seguida, logo depois a regra  $A_3 \rhd A_2A3A_2$ é inserida em $P_1$ que agora tem a forma, 
    $$P_1 = \{A_1 \rhd A_2A_3, A_2 \rhd A_3A_1, A_3 \rhd A_2A_3A_2\}$$
    o valor de $j$ aumenta para $2$ e na próxima interação do \textit{loop} (linha $6$) a regra $A_3 \rhd A_2A3A_2$ será encontra e excluída de $P_1$ em seguida será adicionado em $P_0$ a regra $A_3 \rhd bA_3A_2$ e em $P_1$ será adicionada a regra $A_3 \rhd A_3A_1A_3A_2$ e assim $P_0$ e $P_1$ passa a ser da forma, 
    $$P_0 = \{A_2\rhd b, A_3 \rhd a \mid bA_3A_2\}$$
    e
    $$P_1 = \{A_1 \rhd A_2A_3, A_2 \rhd A_3A_1, A_3 \rhd A_3A_1A_3A_2\}$$
    após isso o \textit{loop} da linha $6$ é finalizando, e o algoritmo segue uma vez que $A_3$ possuem regra recursiva à esquerda (exatamente $A_3 \rhd A_3A_1A_3A_2$) na linha $20$ o conjunto $V'$ é atualizado para a forma $V' = \{A_1, A_2, A_3, Z_3\}$, já os conjuntos $P_0$ e $P_1$ passam a ser da seguinte forma, 
    $$P_0 = \{A_2\rhd b, A_3 \rhd a \mid aZ_3 \mid bA_3A_2 \mid bA_3A_2Z_3\}$$
    e
    $$P_1 = \{A_1 \rhd A_2A_3, A_2 \rhd A_3A_1, Z_3 \rhd A_1A_3A_2 \mid A_1A_3A_2Z_3\}$$
    com a execução do \textit{loop} da linha $24$ concluída o conjunto $P_0$  passa a conter as regras,
    \begin{eqnarray*}
        A_1 & \rhd & bA_3A_2A_1A_3 \mid bA_3A_2Z_3A_1A_3 \mid bA_3 \mid aZ_3A_1A_3 \mid aA_1A_3\\
        A_2 & \rhd & b \mid bA_3A_2A_1 \mid bA_3A_2Z_3A_1 \mid aZ_3A_1 \mid aA_1\\
        A_3 & \rhd & bA_3A_2 \mid bA_3A_2Z_3 \mid aZ_3 \mid a
    \end{eqnarray*}
    em seguida após a execução do \textit{loop} da linha $30$ concluída o conjunto $P_1$  irá conter as regras, 
    \begin{eqnarray*}
        Z_3 & \rhd & bA_3A_2A_1A_3A_3A_2 \mid bA_3A_2A_1A_3A_3A_2Z_3 \mid bA_3A_2Z_3A_1A_3A_3A_2 \mid bA_3A_2Z_3A_1A_3A_3A_2Z_3 \mid\\
        & & bA_3A_3A_2 \mid bA_3A_3A_2Z_3 \mid  aZ_3A_1A_3A_3A_2 \mid aZ_3A_1A_3A_3A_2Z_3 \mid  aA_1A_3A_3A_2 \mid aA_1A_3A_3A_2Z_3
    \end{eqnarray*}
    finalmente é construída a gramática $G' = \langle \{A_1, A_2, A_3, Z_3\}, \{a, b\}, A_1, P' \rangle$ onde $P' = P_0 \cup P_1$.
    \\
\end{example}

Pode-se como explicado em \cite{benjaLivro2010, menezes1998LFA}, resumir o funcionamento do Algoritmo \ref{alg:GLC-FNGreibach} ao receber como entrada uma GLC na forma normal pré-CHomsky nas seguintes etapas:

\begin{enumerate}
    \item Renomear as variáveis.
    \item Garantir que todas as produções seja das formas $A_i \rhd A_jB$ ou $A_j \rhd aB$ com $i \leq j$ e $A_i, A_j \in V, B \in V^*$ e $a \in \Sigma$.
    \item Elmiar as recursões à esquerda, introduzindo com isso novas variáveis rotuladas por $Z_i$ com $i \leq \#V$.
    \item Garantir que todas as regras sejam da forma $A \rhd aB$ com $A \in V'$ e $B V'^*$.
\end{enumerate}

Um fato importante sobre o Algoritmo \ref{alg:GLC-FNGreibach} é que diferentes ordens com que as variáveis são renomeadas geram diferentes gramáticas como resultado. O exemplo a seguir ilustra essa propriedade do Algoritmo \ref{alg:GLC-FNGreibach}.

\begin{example}
    Considere novamente a GLC do Exemplo \ref{exe:GLC-Para_Converter}, e executando as etapas do Algoritmo \ref{alg:GLC-FNGreibach}, porém renomeando as variáveis agora como, $S = A_1, U = A_2$ e $T = A_3$ será gerado a GLC na forma normal de Greibach $G = \langle \{A_1, A_2, A_3, Z_3\}, \{a, b\}, A_1, P\rangle$ com $P$ sendo o conjunto que contém as seguintes regras.
    \begin{eqnarray*}
        A_1 & \rhd & aA_1A_2 \mid bA_2 \mid aA_1Z_3A_2 \mid bZ_3A_2\\
        A_2 & \rhd & aA_1A_2A_3 \mid bA_3A_2A_3 \mid aA_1Z_3A_2A_3 \mid bZ_3A_2A_3 \mid a\\
        A_3 & \rhd & aA_1 \mid b \mid aA_1Z_3 \mid bZ_3\\
        Z_3 & \rhd & aA_1A_2A_3A_3A_1 \mid bA_3A_2A_3A_3A_1 \mid aA_1Z_3A_2A_3A_3A_1 \mid bZ_3A_2A_3A_3A_1 \mid aA_3A_1\\
        & & aA_1A_2A_3A_3A_1Z_3 \mid bA_3A_2A_3A_3A_1Z_3 \mid aA_1Z_3A_2A_3A_3A_1Z_3 \mid bZ_3A_2A_3A_3A_1Z_3 \mid aA_3A_1Z_3
    \end{eqnarray*}
\end{example}


\section{Sobre Algoritmos de Pertinência em GLC}\label{sec:AlgoritmosPertinenciaGLC}

Escrever depois...

\section{Sobre GLC e Linguagens de Programação}\label{sec:GLC-Programacao}

Escrever depois...

\section{Autômatos de Pilha}\label{sec:AutomatoPilha}

Nas Seções \ref{sec:AFD}-\ref{sec:LAFN} do Capítulo \ref{cap:LinguagemRegulares} foram apresentados uma série de três classes de máquinas (os autômatos) que era capazes de reconhecer (ou computar) linguagens regulares. Nesta seção e na próxima seção este manuscrito irá continuar com  este caminho de apresentar as máquinas de computação, ou seja, serão apresentadas modelos de máquina (autômatos) para reconhecer (ou computar) linguagens livres do contexto. 

\begin{figure}[ht]
	\centering
	\begin{tikzpicture}
		\tikzstyle{every path}=[very thick]
		
		\edef\sizetape{0.7cm}
		\tikzstyle{tmtape}=[draw,minimum size=\sizetape]
		
		%% Fita
		\begin{scope}[start chain=1 going right,node distance=-0.15mm]
			\node [on chain=1,tmtape] (input) {$y_1$};
			\node [on chain=1,tmtape] (raiz1) {$\ldots$};
			\node [on chain=1,tmtape] (alvo)  {$y_i$};
			\node [on chain=1,tmtape] (raiz2) {$\ldots$};
			\node [on chain=1,tmtape] (output){$y_n$};
			\node [on chain=1,xshift=0.3cm]        (descr) {\textbf{Memória}};
		\end{scope}
		
		\begin{scope}[shift={(8.0cm,0.0cm)}, start chain=2 going below,node distance=-0.15mm]
		    \node [on chain=2,tmtape] (pilha)  {$\vdots$};
			\node [on chain=2,tmtape] (topo)  {$A_1$};
			\node [on chain=2,tmtape] (s2) {$\vdots$};
			\node [on chain=2,tmtape] (si) {$A_i$};
			\node [on chain=2,tmtape] (s3) {$\vdots$};
			\node [on chain=2,tmtape] (sn) {$A_n$};
			\node [on chain=2,tmtape] (vazia) {$z$};
			\node [on chain=2,xshift=0.3cm] (info) {\textbf{Pilha} \ \ \ \ \  };
		\end{scope}
		
		%% Unidade de Controle
		\begin{scope}
			[shift={(1.5cm,-3.7cm)},start chain=circle placed {at=(-\tikzchaincount*30:1.5)}]
			%\foreach \i in {q_0,p_1,q_2,q_3, q_4,\ddots,q_n}
			\foreach \i in {q_0,q_1, q_2,q_3, q_4,q_5, q_6,q_7, \cdots,\ddots, q_{n-1},q_n}
			\node [on chain] {$\i$};
			
			% Seta para estado corrente
			\node (center) {};
			\draw[->] (center) -- (circle-2);
			
			\node[rounded corners,draw=black,thick,fit=(circle-1) (circle-2) (circle-3) 
			(circle-4) (circle-5) (circle-6) (circle-7) (circle-8) 
			(circle-9) (circle-10) (circle-11) (circle-12),
			label=right:\textbf{Unidade de Controle}] (fsbox)
			{};
		\end{scope}
		
		%% Draw TM head below (input) tape cell
		\node [draw=white, thick, yshift=-.3cm] at (alvo.south)   (head3) {};
		
		
	\end{tikzpicture}
	\caption{Conceito informal de autômato de Pilha.}
	\label{fig:AP-Informal}
\end{figure}

Um autômato de pilha pode ser compreendido como sendo um computador com uma estrutura formado por três partes (a) uma memória somente de leitura, (b) uma unidade de controle e (c) uma memória de escrita e leitura na forma de uma pilha. A figura \ref{fig:AP-Informal} ilustra essa visão conceitual da estrutura dos autômatos de pilha.

Os dois primeiros componentes dos autômatos de pilha são similares aquele que o leitor já encontrou no Capítulo \ref{cap:LinguagemRegulares} quando esteve em contato com os AFD, AFN e $\lambda$-AFN. O terceiro componente (a pilha) é uma memória\footnote{Assim com a memória só de escrita, a pilha tem a natureza de ser dividida em cédulas, em que cada cédula pode armazenar o único símbolos por vez.} cujo acesso obedece os critérios de uma estrutura de dados d tipo pilha \cite{jaime1994}, em tal memória será sempre possível ler o topo da pilha e remover (fazer \textit{pop}) ou escrever (\textit{push}) sob o topo da pilha.

Para simplificar o entendimento inicial do leitor será primeiro apresentado um modelo determinístico do Autômatos de pilha, o modelo aqui apresentado é o mesmo usado em \cite{benjaLivro2010}, vale salientar que este modelo é equivalente em poder computacional aos modelos usuais usados em \cite{harrison1978, hopcroft2008}, ou seja, ele reconhece a mesma classe de linguagens. O modelo usual encontrado na literatura será detalhado e usado mais adiante neste manuscrito.

\begin{definition}[Autômato de Pilha Determinístico]\label{def:APD}
    Um Autômato de Pilha Determinístico, ou simplesmente APD, é uma estrutura $A = \langle Q, \Sigma, \Gamma, \delta, q_0, z, F\rangle$ onde, $Q$ é um conjunto finito e não vazio de estados, $\Sigma$ é o alfabeto de entrada, $\Gamma$ é o alfabeto da pilha, $\delta: Q \times \Sigma \times \Gamma  \rightarrow Q \times \Gamma^*$ é uma função total de transição entre os estados do autômato, $q_0 \in Q$ é o estado inicial do APD, $z \in \Gamma$ é um símbolo especial chamado de símbolo de fim da pilha\footnote{Para o leitor conhecedor dos fundamentos de estrutura de dados e programação, o símbolo da pilha vazia pode ser visto como sendo o ponteiro que aponta para \textit{null} indicado o fim da pilha.} e  $F \subseteq Q$ é um conjunto de estados finais
\end{definition}

\begin{remark}
    Em obras como \cite{benjaLivro2010, harrison1978, hopcroft2008, menezes1998LFA} o símbolo $z$ costuma ser chamado de símbolo da pilha vazia.
\end{remark}

\begin{example}
    A Estrutura $A = \langle \{q_0, q_1\}, \{a, b\}, \{A, z\}, \delta, q_0, z, \{q_1\} \rangle$ com $\delta$ definido a seguir é um APD.
    \begin{eqnarray*}
        \delta(q_0, a, z) & = & (q_0, Az)\\
        \delta(q_0, a, A) & = & (q_0, AA)\\
        \delta(q_0, b, z) & = & (q_0, z)\\
        \delta(q_0, b, A) & = & (q_1, \lambda)\\
        \delta(q_1, a, z) & = & (q_0, z)\\
        \delta(q_1, a, A) & = & (q_0, \lambda)\\
        \delta(q_1, b, z) & = & (q_0, z)\\
        \delta(q_1, b, A) & = & (q_1, \lambda)
    \end{eqnarray*}
\end{example}

Pode-se interpretar que $\delta(q_i, a, A) = (q_j, A_1A_2\cdots A_n)$ como sendo uma instrução com o seguinte significado, estando o autômato (ou a máquina) no estado $q_i$ e se o cabeçote da memória estiver sobre a cédula que contém $a$ e, além disso, estando o símbolo $A$ no top da pilha, então o autômato muda para estado $q_j$ e a palavra $A_1A_2\cdots A_n$ é empilhada\footnote{Como dito é \cite{benjaLivro2010}, quando uma palavra $A_1A_2\cdots A_n$ é empilhada no top da pilha, os símbolos da pilha sofrem \textit{push} de forma reversar, assim é $A_n$ substitui o atual topo da pilha,  depois $A_{n-1}$ é inserido na cédula sobre á cédula que guarda $A_n$, e isso se repete até que $A_1$ seja colocada na pilha, por fim o topo da pilha passa a ser $A_1$.} no top da pilha. Sobre as transições, elas podem ser categorizadas em 3 classes: 

\begin{itemize}
    \item Transições de consulta, são aquelas que o símbolo exigido no topo da pilha é o mesmo que será escrito, ou seja, a transição tem a forma $\delta(q_i, a, A) = (q_i, A)$.
    \item Transições de inserção (ou \textit{push}), são aquelas que aumentam o tamanho da pilha, ou seja, essa transições expandem o tamanho da pilha, o leitor reconhecerá essas transições pela forma $\delta(q_i, a, A) = (q_j, A_1\cdots A_n)$ com $n \geq 2$.
    \item  Transições de remoção (ou \textit{pop}), são aquelas que diminuem o tamanho da pilha, ou seja, essa transições reduzem o tamanho da pilha, tais transições tem a forma $\delta(q_i, a, A) = (q_j, \lambda)$.
\end{itemize}

Agora que já foram introduzidos os conceito básicos a certa dos autômatos de pilha em sua versão mais simples, isto é, na versão determinística, este manuscrito irá prosseguir apresentado a versão não-determinística.

\begin{definition}[Autômato de Pilha Não-determinístico]\label{def:APN}
    Um Autômato de Pilha Determinístico, ou simplesmente APN, é uma estrutura $A = \langle Q, \Sigma, \Gamma, \delta, q_0, z, F\rangle$ onde, $Q, \Sigma, \Gamma, q_0, z, F$ são da mesma forma que na Definição \ref{def:APD} e $\delta$ é uma função parcial com a seguinte assinatura $\delta: Q \times (\Sigma \cup \{\lambda\}) \times \Gamma \rightarrow \wp^{fim}(Q \times \Gamma^*)$.
\end{definition}

\begin{remark}
    Como dito em \cite{harrison1978} na notação $\wp^{fim}(Q \times \Gamma^*)$ denota uma familia finita de subconjuntos de $Q \times \Gamma^*$.
\end{remark}

\begin{example}\label{exe:APN1}
    A Estrutura $A = \langle \{q_0, q_1, q_2\}, \{a, b\}, \{A, z\}, \delta, q_0, z, \{q_2\} \rangle$ com $\delta$ definido como sendo, 
    \begin{eqnarray*}
        \delta(q_0, a, z) & = & \{(q_0, AAz)\}\\
        \delta(q_0, a, A) & = & \{(q_0, AA)\}\\
        \delta(q_0, b, A) & = & \{(q_1, \lambda)\}\\
        \delta(q_1, b, A) & = & \{(q_1, \lambda)\}\\
        \delta(q_1, c, A) & = & \{(q_2, \lambda)\}\\
        \delta(q_2, c, A) & = & \{(q_2, \lambda)\}
    \end{eqnarray*}
    é um APN.
\end{example}

Um ponto a se destacar neste momento é que a versão determinística dos autômatos de pilha apresentados em obras como \cite{harrison1978, hopcroft2008, sipser2010} consiste na verdade de um APN que para todo $q \in Q, a \in \Sigma \cup \{\lambda\}$ e $A \in \Sigma$ obedece as seguintes restrições:
\begin{itemize}
    \item[(1)] $\# \delta(q, a, A) \leq 1$ e 
    \item[(2)] Se $\delta(q, \lambda, A) \neq \emptyset$, então $\delta(q, a, A) = \emptyset$.
\end{itemize}
O leitor atento pode notar que o APN no Exemplo \ref{exe:APN1} é na verdade um APD.

Com respeito a representação visual, um APN (ou APD) pode ser representado usando grafos de transição, como para o caso dos autômatos do Capítulo \ref{cap:LinguagemRegulares} os estados são as arestas que são desenhada com círculos usando a seguinte regra se $q \in F$ então é desenhado círculos duplo se não é um círculo simples, já no caso de $(q_j, A_1\cdots A_n) \in \delta(q_i, a, A_0)$ então é desenhada um vértice ligando as arestas $q_i$ e $q_j$, tal que este vértice é rotulado por $a,A_0 \mid A_1\cdots A_n$, com $a \in \Sigma \cup \{\lambda\}$ e $A_i \in \Gamma^*$ para $0 \leq i \leq n-1$. 

\begin{example}\label{exe:GrafoAPN1}
	O APN do Exemplo \ref{exe:APN1} pode ser representado pelo seguinte grafo de transição
	
	\begin{figure}[h]
		\centering
		\begin{tikzpicture}[>=stealth, shorten >=1pt, node distance=3.0cm, on grid, auto, state/.append style={minimum size=3em}, thick ]
			\node[state, initial]						(A)               	{$q_0$};
			\node[state]								(B) [right of=A] 	{$q_1$};
			\node[state, accepting]				        (C) [right of=B] 	{$q_2$};
			\path[->] (A) +(-1,0) edge (A)
			
			%[align=center]   {$(a, 11)$\\$(b, 20)$} (B)
			%Transições:
			%(Partida) edge [tipo da seta] node {simbolo lido} (Destino)
			(A) edge [loop above]  				node [align=center] {$a,z\mid AAz$\\$a,A\mid AA$} 		 ( )
			(A) edge 			  				node 		 {$b,A\mid \lambda$} (B)
			(B) edge [loop above]  				node 		 {$b,A\mid \lambda$} 		 ( )
			(B) edge 			  				node 		 {$c,A\mid \lambda$} (C)
			(C) edge [loop above]  				node 		 {$c,A\mid \lambda$} 		 ( );
		\end{tikzpicture}
		\caption{Grafo de transição do APN do Exemplo \ref{exe:APN1}.}
		\label{fig:APN1}
	\end{figure}
\end{example}

A qualquer momento no tempo pode-se com dito em \cite{harrison1978} descrever a atual configuração de um APN (ou APD) através do conhecimento de três informações:  O estado atual do APN (ou APD), o que resta para ser processado na memória e  conteúdo da pilha.

\begin{definition}[Descrição Instantânea]\label{def:DI-APD}
    Dado um APN (APD) $A = \langle Q, \Sigma, \Gamma, \delta, q_0, z, F\rangle$ uma descrição instantânea (d.i.) de $A$, é uma tripla $(q, w, W)$ com $q \in Q, w \in \Sigma^*$ e $W \in \Gamma^*$. O conjunto de todas as descrições instantâneas sobre $A$ é denotado por $DI_A$.
\end{definition}

\begin{remark}
    Sempre que não causar confusão a escrita $DI_A$ pode ser modificada para $DI$.
\end{remark}

Sobre o conjunto de todas as descrições instantâneas é possível definir uma relação de movimento (ou mudança), tal relação na verdade descreve a execução de um passo de computação em um autômato de pilha, independente de ser determinístico ou não.

\begin{definition}[Relação de Movimento]
    Dado um APN (APD) $A = \langle Q, \Sigma, \Gamma, \delta, q_0, z, F\rangle$ a relação de movimento sobre $DI$, denotada por $\twoheadrightarrow$, é dada por, 
    \begin{equation}
        (q_i, aw, A\beta z) \twoheadrightarrow (q_j, w, \alpha\beta z) \Longleftrightarrow (q_j, \alpha) \in \delta(q_i, a, A)
    \end{equation}
    Por sua vez, o fecho transitivo e reflexivo de $\twoheadrightarrow$ e denotado por $\twoheadrightarrow^*$.
\end{definition}

\begin{example}
    Considere o APN do Exemplo \ref{exe:APN1} tem-se que,
    $$(q_0, aaaabbcc, z) \twoheadrightarrow (q_0, aaabbcc, AAz)$$
    pois $(q_0, AAz) \in (q_0, a, z)$. Além disso, é fácil mostrar que
    $$(q_0, aaaabbcc, z) \twoheadrightarrow^* (q_2, \lambda, z)$$
\end{example}

Após apresentar a relação de movimento é possível seguir em frente e formalizar o conceito de palavra aceita por autômatos de pilha, como apresentado em \cite{harrison1978} existe no mínimo duas forma com que um autômato de pilha aceita uma palavra de entrada, a primeira seria o autômato simplesmente após lê toda a palavra de entrada atingir um estado final e a segunda opção que é aquela em que o autômato deve lê toda a palavra de entrada, atingir um estado final e ter a pilha vazia\footnote{Na visão (praticamente dogmática) do autor deste manuscrito, ele acredita que a segunda opção é mais compatível com a natureza dos APN e APD como sendo computadores munidos de ferramenta de controle por contagem.}.

\begin{definition}[Linguagem Aceita por Estado final]
    Dado um APN (APD) $A = \langle Q, \Sigma, \Gamma, \delta, q_0, z, F\rangle$ a linguagem de $A$ aceita por estado final corresponde ao seguinte conjunto, 
    \begin{equation}
        \mathcal{L}_{F}(A) = \{w \in \Sigma^* \mid (q_0, w, z) \twoheadrightarrow^* (q_f, \lambda, u), q_f \in F, u \in \Gamma^*\}
    \end{equation}
\end{definition}

\begin{definition}[Linguagem Aceita por Pilha vazia]
    Dado um APN (APD) $A = \langle Q, \Sigma, \Gamma, \delta, q_0, z, F\rangle$ a linguagem de $A$ aceita por pilha vazia corresponde ao seguinte conjunto, 
    \begin{equation}
        \mathcal{L}_{z}(A) = \{w \in \Sigma^* \mid (q_0, w, z) \twoheadrightarrow^* (q_f, \lambda, z), q_f \in F\}
    \end{equation}
\end{definition}

Como mostrado em \cite{hopcroft2008} uma linguagem $L$ será aceita por um APN $A$ por pilha vazia se, e somente se, existir outro APN $A'$ que aceita $L$ por estado final.

\begin{remark}
	Para esse questionário sempre que $w \in \Sigma^*$ e $c \in \Sigma$ a notação $|w|_c$ irá representar o número de $c$'s que existem na palavra $w$.
\end{remark}

\begin{problemset}
    \item Prove que a linguagem $\{ w \in \{0, 1\}^* \mid |w|_0 = |w|_1 \text{ e } |u|_0 \geq |u|_1, u \in PRE(w)\}$ é gera pela GLC com o seguinte conjunto de produções,
    \begin{equation}
        S \rhd 0S1 \mid SS \mid \lambda
    \end{equation}
    
    \item Usando a GLC do exercício anterior desenhe as árvores de derivação para as palavras $abaabb, aabbaabb$ e $abababab$.
    
    \item Exiba uma GLC para cada linguagem a seguir.
    \begin{enumerate}
        \item $\{a^nb^m \mid n \neq m - 1\}$
        \item $\{1^n0^m \mid n \neq 2m\}$
        \item $\{0^n1^m \mid n \leq m + 4\}$
        \item $\{a^nb^m \mid 2m \leq n + 1\}$
        \item $\{a^nb^mc^k \mid m = n \text{ ou } m \leq k\}$
        \item $\{a^nb^mc^k \mid k = n \text{ ou } m \neq n\}$
        \item $\{a^{2n}b^{n}c^{n} \mid n \geq 2\}$
        \item $\{w \in \{0, 1, 2\} \mid |w|_1 = 2k + 1, k \in \mathbb{N}\}$
        \item $\{0^ib^ja^k \mid i, k \in \mathbb{N},  j = 2k + i\}$
        \item $\{0^ib^ja^k \mid i, k \in \mathbb{N}, 2i = j + k\}$
        \item $\{0^ib^ja^k \mid j, k \in \mathbb{N} i = 2k + j + 3\}$
        \item $\{a^ib^jc^k \mid j, k \in \mathbb{N} j = 2(i + k) + 1\}$
        \item $\{wu^nw^r \mid u \in \{0, 1\}^+, w \in \{a, b\}^*, n \in \mathbb{N}\}$
    \end{enumerate}
    
    \item Considere a linguagem $L =\{0^n1^n \mid n \in \mathbb{N}\}$ prove para todo $k \in \mathbb{N}$ que a linguagem $L^k$ é livre do contexto.
    
    \item Prove que $00110110 \notin \mathcal{L}(G)$ onde $G$ é a GLC que tem o seguinte conjunto de regras e $S$ sendo o símbolo inicial.
    \begin{eqnarray*}
        S & \rhd & 00Y\\
        X & \rhd & 1Y1 \mid \lambda\\
        Y & \rhd & X0
    \end{eqnarray*}
    
    \item Remova a recursão à esquerda da GLC com o seguinte conjunto de regras com $\Sigma = \{0, 1\}$ e $S$ sendo o símbolo inicial.
    \begin{eqnarray*}
        S & \rhd & 010S \mid SS \mid SS01 \mid 01
    \end{eqnarray*}
    
    \item Remova a recursão à esquerda da GLC com o seguinte conjunto de regras com $\Sigma = \{0, 1\}$ e $S$ sendo o símbolo inicial.
    \begin{eqnarray*}
        S & \rhd & S1 \mid AS \mid \lambda\\
        A & \rhd & A0 \mid 0
    \end{eqnarray*}
    
    \item Remova a recursão à esquerda da GLC com o seguinte conjunto de regras com $\Sigma = \{0, 1, 2\}$ e $S$ sendo o símbolo inicial.
    \begin{eqnarray*}
        S & \rhd & 2Z \mid S10S\\
        Z & \rhd & 2Z1 \mid \lambda
    \end{eqnarray*}
    
    \item Construa uma GLC sem recursão à esquerda que gerar a linguagem $\{w \in \{0, 1\}^* \mid |w|_1 > |w|_0\}$.
    
    \item Elimine as regras inúteis da GLC com o conjunto de regras a seguir e sendo $\Sigma = \{a, b, c, d\}$ e $S$ sendo o símbolo inicial.
    \begin{eqnarray*}
        S & \rhd & a \mid aB \mid B \mid C\\
        A & \rhd & aB \mid \lambda\\
        B & \rhd & Aa \\
        C & \rhd & cCD\\
        D & \rhd & dd \mid ddD
    \end{eqnarray*}
    
    \item Elimine as $\lambda$-produções da GLC com o conjunto de regras a seguir e sendo $\Sigma = \{0, 1\}$ e $S$ sendo o símbolo inicial.
    \begin{eqnarray*}
        S & \rhd & A0B \mid 0C0B\\
        A & \rhd & 0B0 \mid \lambda \mid B\\
        B & \rhd & 11A \mid \lambda \\
        C & \rhd & 111C \mid AB
    \end{eqnarray*}
    
    \item Considerando $\Sigma = \{0, 1\}$ e $S$  remova todas as $\lambda$-produções, regras unitárias e recursão à esquerda das GLC a seguir.
    \begin{enumerate}
        \item Com $S$ sendo a variável inicial e $P$ é formado por,
        \begin{eqnarray*}
            S & \rhd & S0 \mid 0AB\\
            A & \rhd & B \mid aa \mid \lambda\\
            B & \rhd & A1B \mid \lambda \mid C \\
            C & \rhd & 0CC0 \mid ABC
        \end{eqnarray*}
        
        \item Com $A$ sendo a variável inicial e $P$ é formado por,
        \begin{eqnarray*}
            S & \rhd & 0S0 \mid \lambda\\
            A & \rhd & SASA \mid B\\
            B & \rhd & 1B \mid C \mid D1 \\
            C & \rhd & 0C1 \mid 01\\
            D & \rhd & D0 \mid 1D
        \end{eqnarray*}
        
        \item Com $C$ sendo a variável inicial e $P$ é formado por,
        \begin{eqnarray*}
            S & \rhd & 0A \mid 0B \mid S0A\\
            A & \rhd & B \mid 00 \mid \lambda\\
            B & \rhd & 1B \mid \lambda \mid C \\
            C & \rhd & 0C0 \mid ABC
        \end{eqnarray*}
        
        \item Com $B$ sendo a variável inicial e $P$ é formado por,
        \begin{eqnarray*}
            S & \rhd & S10A \mid A0B \mid S0A11\\
            A & \rhd & AB \mid A00 \mid 00 \mid \lambda\\
            B & \rhd & 1B \mid \lambda \mid BC \mid BBS \mid BB0S \\
            C & \rhd & B \mid CBA \mid CA \mid A \mid C \mid 1 \mid \lambda
        \end{eqnarray*}
    \end{enumerate}
    
    \item Converta para a forma normal pré-Chomsky todas as GLC dos exercício de 5 até 8.
    
    \item Converta para a forma normal pré-Chomsky as GLC dos exercício de 10 e 11.
    
    \item Converta para a forma normal Chomsky as GLC dos exercício de 13 e 14.
    
    \item Converta para a forma normal Chomsky todas as GLC do exercício 12, 13, 14.
    
    \item Converta para a forma normal Greibach todas as GLC do exercício 12, 13, 14.
    
    \item Esboce um APN ou APD para cada linguagem do exercício 3.
\end{problemset}